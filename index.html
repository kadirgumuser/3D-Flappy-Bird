<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <title>3D Flappy - Platform Optimize</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #87CEEB;
            font-family: sans-serif;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #control-layer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            z-index: 10;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 15px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.8);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        #output_canvas {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        #webcam {
            display: none;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 20;
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 12px;
            font-size: 18px;
            pointer-events: none;
            border-left: 5px solid #00FFFF;
        }

        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            display: none;
            z-index: 30;
            background: rgba(0, 0, 0, 0.9);
            padding: 50px;
            border-radius: 25px;
            border: 3px solid #e74c3c;
            box-shadow: 0 0 50px rgba(231, 76, 60, 0.5);
        }

        button {
            padding: 15px 40px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 10px;
            border: none;
            background: #e74c3c;
            color: white;
            font-weight: bold;
            margin-top: 20px;
        }

        .highlight {
            color: #00FFFF;
            font-weight: bold;
        }

        #fps {
            position: absolute;
            top: 20px;
            right: 360px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 20;
        }

        /* Global Cursor */
        #game-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 3px solid #00FFFF;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 0 10px #00FFFF, inset 0 0 10px #00FFFF;
            transform: translate(-50%, -50%);
            display: none;
            /* Ä°lk baÅŸta gizli */
        }

        /* Power-Up Status */
        /* UI Status Display */
        #status-display {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 48px;
            font-weight: 900;
            text-shadow: 0 0 20px #FF0000, 2px 2px 0px #000;
            display: none;
            z-index: 25;
            text-align: center;
            font-family: 'Impact', sans-serif;
            letter-spacing: 2px;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>

    <div id="info">
        <h2 style="margin-top:0">ðŸŽ® 3D FLAPPY BIRD</h2>
        <p>Klasik Flappy Bird mekaniÄŸi!</p>
        <p>1. <span class="highlight">YÃ–N:</span> Ä°mleci SaÄŸa/Sola gÃ¶tÃ¼r.</p>
        <p>2. <span class="highlight">ZIPLA:</span> Pinch (Ã‡imdik) yap!</p>
        <p style="margin-top:10px; font-size:14px; opacity:0.8;">ðŸ’¡ TÄ±kla â†’ ZÄ±pla â†’ DÃ¼ÅŸ â†’ Tekrar TÄ±kla</p>
        <p style="margin-top:15px; font-size:24px">Skor: <span id="scoreVal" class="highlight">0</span></p>
    </div>

    <div id="fps">FPS: <span id="fpsVal">60</span></div>
    <div id="game-cursor"></div>
    <div id="game-cursor"></div>
    <div id="status-display"></div>

    <div id="gameOverScreen">
        <h1 style="font-size: 60px; margin: 0; color: #e74c3c;">KAZA!</h1>
        <p style="font-size: 30px;">Skorun: <span id="finalScore">0</span></p>
        <button onclick="resetGame()">TEKRAR DENE</button>
    </div>

    <div id="control-layer">
        <canvas id="output_canvas" width="320" height="240"></canvas>
    </div>
    <video id="webcam" playsinline></video>

    <div id="game-container"></div>

    <script>
        // --- DELTA TIME TABANLI AYARLAR ---
        const CAMERA_WIDTH = 320;
        const CAMERA_HEIGHT = 240;

        // Oyun DeÄŸiÅŸkenleri
        let camera, scene, renderer;
        let bird, pipes = [];
        let roadSegments = [];
        let gameActive = false;
        let score = 0;
        let birdVelocityY = 0;
        let targetBirdX = 0;
        let lastPipeZ = -20;
        let lastRoadZ = 0;

        // DELTA TIME iÃ§in
        let lastTime = performance.now();
        let deltaTime = 0;
        const TARGET_FPS = 60;
        const FIXED_TIME_STEP = 1000 / TARGET_FPS; // 16.67ms

        // FPS Counter
        let frameCount = 0;
        let fpsTime = 0;
        let currentFPS = 60;

        // Fizik sabitleri (saniyede birim olarak) - FLAPPY BIRD TARZI
        const GRAVITY = 18.5; // birim/saniyeÂ² - Daha hÄ±zlÄ± dÃ¼ÅŸÃ¼ÅŸ
        const JUMP_STRENGTH = 12.0; // birim/saniye - Net zÄ±plama
        const GAME_SPEED = 6.0; // birim/saniye
        const MAX_FALL_SPEED = -10.0; // Maksimum dÃ¼ÅŸÃ¼ÅŸ hÄ±zÄ± sÄ±nÄ±rÄ±
        const PIPE_DISTANCE = 50;

        // Harita SÄ±nÄ±rlarÄ±
        const ROAD_WIDTH = 28;
        let PLAY_WIDTH = 14.0; // const yerine let yaptÄ±k ki deÄŸiÅŸebilsin

        // --- POWER-UP SÄ°STEMÄ° ---
        let powerUps = [];
        let shieldActive = false;
        let shieldTimer = 0;
        let wallBreakerActive = false;
        let wallBreakerTimer = 0;
        let originalPlayWidth = 14.0;
        const WALL_HEIGHT = 15;
        const PIPE_WIDTH = 6;
        const PIPE_GAP_Y = 9;

        // El Takibi - FLAPPY BIRD TARZI
        let isPinching = false;
        let lastPinchTime = 0;
        const PINCH_COOLDOWN = 200; // Orta seviye cooldown
        const PINCH_THRESHOLD = 0.055; // Ã‡imdik hassasiyeti

        // YumuÅŸatma iÃ§in
        let currentBirdOffset = 0;
        let cameraCurrentOffset = 0;

        init3D();
        setupMediaPipe();
        animate();

        function init3D() {
            const container = document.getElementById('game-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.012);

            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 4, 15);
            camera.lookAt(0, 0, -10);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 80, 30);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.1;
            dirLight.shadow.camera.far = 500;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            scene.add(dirLight);

            for (let i = 0; i < 50; i++) {
                createRoadSegment();
            }

            bird = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.7, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0xf1c40f, roughness: 0.4 })
            );
            body.castShadow = true;
            bird.add(body);

            const wing = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 0.1, 0.8),
                new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 })
            );
            wing.castShadow = true;
            bird.add(wing);

            const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(-0.25, 0.3, 0.5);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeR.position.set(0.25, 0.3, 0.5);
            bird.add(eyeL);
            bird.add(eyeR);
            scene.add(bird);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function getRoadX(z) {
            return Math.sin(z * 0.05) * 15;
        }

        function createRoadSegment() {
            const segmentLength = 5;
            const z = lastRoadZ;
            const nextZ = z - segmentLength;
            const x = getRoadX(z);
            const nextX = getRoadX(nextZ);
            const halfWidth = ROAD_WIDTH / 2;
            const y = -3;

            const p1 = new THREE.Vector3(x - halfWidth, y, z);
            const p2 = new THREE.Vector3(x + halfWidth, y, z);
            const p3 = new THREE.Vector3(nextX - halfWidth, y, nextZ);
            const p4 = new THREE.Vector3(nextX + halfWidth, y, nextZ);

            const roadGeo = new THREE.BufferGeometry();
            const roadVertices = new Float32Array([
                p1.x, p1.y, p1.z,
                p2.x, p2.y, p2.z,
                p3.x, p3.y, p3.z,
                p2.x, p2.y, p2.z,
                p4.x, p4.y, p4.z,
                p3.x, p3.y, p3.z
            ]);
            roadGeo.setAttribute('position', new THREE.BufferAttribute(roadVertices, 3));
            roadGeo.computeVertexNormals();

            const roadMat = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                roughness: 0.8,
                side: THREE.DoubleSide
            });
            const road = new THREE.Mesh(roadGeo, roadMat);
            road.receiveShadow = true;
            scene.add(road);

            const wallMat = new THREE.MeshBasicMaterial({
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });

            const leftWallGeo = new THREE.BufferGeometry();
            const h = WALL_HEIGHT;
            const lwVertices = new Float32Array([
                p1.x, p1.y, p1.z,
                p3.x, p3.y, p3.z,
                p1.x, p1.y + h, p1.z,
                p3.x, p3.y, p3.z,
                p3.x, p3.y + h, p3.z,
                p1.x, p1.y + h, p1.z
            ]);
            leftWallGeo.setAttribute('position', new THREE.BufferAttribute(lwVertices, 3));
            leftWallGeo.computeVertexNormals();
            const leftWall = new THREE.Mesh(leftWallGeo, wallMat);
            scene.add(leftWall);

            const rightWallGeo = new THREE.BufferGeometry();
            const rwVertices = new Float32Array([
                p2.x, p2.y, p2.z,
                p4.x, p4.y, p4.z,
                p2.x, p2.y + h, p2.z,
                p4.x, p4.y, p4.z,
                p4.x, p4.y + h, p4.z,
                p2.x, p2.y + h, p2.z
            ]);
            rightWallGeo.setAttribute('position', new THREE.BufferAttribute(rwVertices, 3));
            rightWallGeo.computeVertexNormals();
            const rightWall = new THREE.Mesh(rightWallGeo, wallMat);
            scene.add(rightWall);

            roadSegments.push({ mesh: road, left: leftWall, right: rightWall, z: z });
            lastRoadZ = nextZ;

            if (roadSegments.length > 100) {
                const old = roadSegments.shift();
                scene.remove(old.mesh);
                scene.remove(old.left);
                scene.remove(old.right);
                old.mesh.geometry.dispose();
                old.mesh.material.dispose();
                old.left.geometry.dispose();
                old.left.material.dispose();
                old.right.geometry.dispose();
                old.right.material.dispose();
            }
        }

        function createPipe() {
            const pipeZ = lastPipeZ - PIPE_DISTANCE;
            const roadX = getRoadX(pipeZ);
            const limitX = PLAY_WIDTH - 1.5;
            const randomOffset = (Math.random() * (limitX * 2)) - limitX;
            const randomX = roadX + randomOffset;
            const randomY = Math.random() * 5 + 1;

            const pipeMat = new THREE.MeshStandardMaterial({ color: 0x00AA00, roughness: 0.5 });

            const upperGeo = new THREE.CylinderGeometry(PIPE_WIDTH / 2, PIPE_WIDTH / 2, 15, 16);
            const upperPipe = new THREE.Mesh(upperGeo, pipeMat);
            upperPipe.position.set(randomX, randomY + PIPE_GAP_Y / 2 + 7.5, pipeZ);
            upperPipe.castShadow = true;
            upperPipe.receiveShadow = true;

            const lowerGeo = new THREE.CylinderGeometry(PIPE_WIDTH / 2, PIPE_WIDTH / 2, 15, 16);
            const lowerPipe = new THREE.Mesh(lowerGeo, pipeMat);
            lowerPipe.position.set(randomX, randomY - PIPE_GAP_Y / 2 - 7.5, pipeZ);
            lowerPipe.castShadow = true;
            lowerPipe.receiveShadow = true;

            const capGeo = new THREE.CylinderGeometry(PIPE_WIDTH / 1.8, PIPE_WIDTH / 1.8, 0.5, 16);
            const uCap = new THREE.Mesh(capGeo, pipeMat);
            uCap.position.set(randomX, randomY + PIPE_GAP_Y / 2 + 0.25, pipeZ);
            uCap.castShadow = true;
            uCap.receiveShadow = true;

            const lCap = new THREE.Mesh(capGeo, pipeMat);
            lCap.position.set(randomX, randomY - PIPE_GAP_Y / 2 - 0.25, pipeZ);
            lCap.castShadow = true;
            lCap.receiveShadow = true;

            const vWallGeo = new THREE.PlaneGeometry(ROAD_WIDTH * 1.5, 30);
            const vWallMat = new THREE.MeshBasicMaterial({
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });

            const gapSize = PIPE_WIDTH + 2;
            const leftW = new THREE.Mesh(vWallGeo, vWallMat);
            leftW.position.set(randomX - (gapSize / 2 + ROAD_WIDTH * 0.75), 0, pipeZ);

            const rightW = new THREE.Mesh(vWallGeo, vWallMat);
            rightW.position.set(randomX + (gapSize / 2 + ROAD_WIDTH * 0.75), 0, pipeZ);

            scene.add(upperPipe);
            scene.add(lowerPipe);
            scene.add(uCap);
            scene.add(lCap);
            scene.add(leftW);
            scene.add(rightW);

            pipes.push({
                upper: upperPipe,
                lower: lowerPipe,
                uCap: uCap,
                lCap: lCap,
                leftW: leftW,
                rightW: rightW,
                x: randomX,
                offset: randomOffset,
                yCenter: randomY,
                passed: false,
                z: pipeZ
            });
            lastPipeZ = pipeZ;
        }

        function createPowerUp() {
            // Power-Up'Ä± borudan biraz daha ileri koy
            const itemZ = lastPipeZ - 30; // 30 birim ileri
            const roadX = getRoadX(itemZ);

            // Yolun ortalarÄ±nda spawn olsun
            const limitX = 8.0;
            const randomOffset = (Math.random() * (limitX * 2)) - limitX;
            const itemX = roadX + randomOffset;
            const itemY = Math.random() * 5 + 3;

            const type = Math.random() < 0.5 ? 'shield' : 'wallBreaker';
            let mesh;

            if (type === 'shield') {
                // SHIELD: Mavi, Transparan KÃ¼re
                const geo = new THREE.SphereGeometry(1.5, 32, 32);
                const mat = new THREE.MeshPhongMaterial({
                    color: 0x00BFFF,
                    emissive: 0x0000AA,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.9
                });
                mesh = new THREE.Mesh(geo, mat);
            } else {
                // WALL BREAKER: KÄ±rmÄ±zÄ±, Parlak KÃ¼p
                const geo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
                const mat = new THREE.MeshPhongMaterial({
                    color: 0xFF0000,
                    emissive: 0xFF4500,
                    shininess: 100
                });
                mesh = new THREE.Mesh(geo, mat);
            }

            mesh.position.set(itemX, itemY, itemZ);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            // DÃ¶nÃ¼ÅŸ iÃ§in baÅŸlangÄ±Ã§ rotasyonu
            mesh.rotation.y = Math.random() * Math.PI;
            mesh.rotation.z = Math.random() * Math.PI;

            scene.add(mesh);

            powerUps.push({
                mesh: mesh,
                type: type,
                x: itemX,
                z: itemZ,
                passed: false
            });

            // --- DYNAMIC PACING ---
            // Power-Up spawn olduÄŸunda bir sonraki boruyu Ã§ok daha uzaÄŸa at!
            // BÃ¶ylece oyuncu power-up'Ä± aldÄ±ktan sonra "nefes alma" anÄ± yaÅŸar.
            lastPipeZ = itemZ - 40; // 40 birim "SAFE ZONE"
        }

        function updateGame(dt) {
            if (!gameActive) return;

            // dt saniye cinsinden (Ã¶rn: 0.0167 = 16.7ms)
            const dtSeconds = dt / 1000;

            // Fizik gÃ¼ncellemeleri - FLAPPY BIRD TARZI
            bird.position.z -= GAME_SPEED * dtSeconds;

            // YerÃ§ekimi her zaman aktif
            birdVelocityY -= GRAVITY * dtSeconds;

            // Maksimum dÃ¼ÅŸÃ¼ÅŸ hÄ±zÄ±nÄ± sÄ±nÄ±rla
            if (birdVelocityY < MAX_FALL_SPEED) {
                birdVelocityY = MAX_FALL_SPEED;
            }

            bird.position.y += birdVelocityY * dtSeconds;

            // Fizik gÃ¼ncellemeleri - FLAPPY BIRD TARZI
            bird.position.z -= GAME_SPEED * dtSeconds;

            // YerÃ§ekimi her zaman aktif
            birdVelocityY -= GRAVITY * dtSeconds;

            // Maksimum dÃ¼ÅŸÃ¼ÅŸ hÄ±zÄ±nÄ± sÄ±nÄ±rla
            if (birdVelocityY < MAX_FALL_SPEED) {
                birdVelocityY = MAX_FALL_SPEED;
            }

            bird.position.y += birdVelocityY * dtSeconds;

            const currentRoadX = getRoadX(bird.position.z);

            // --- HAREKET MANTIÄžI GÃœNCELLEMESÄ° ---
            // Eski yÃ¶ntem: Mutlak X pozisyonunu yumuÅŸatÄ±yorduk, bu da yol dÃ¶ndÃ¼ÄŸÃ¼nde gecikmeye (lag) sebep oluyordu.
            // Yeni yÃ¶ntem: Sadece "yola gÃ¶re ofseti" yumuÅŸatÄ±yoruz. Yolun dÃ¶nÃ¼ÅŸÃ¼nÃ¼ anlÄ±k olarak ekliyoruz.

            // Hedef ofsetimiz (targetBirdX zaten yola gÃ¶re ofset olarak hesaplanÄ±yor)
            const targetOffset = targetBirdX;

            // YumuÅŸak geÃ§iÅŸ (frame-independent)
            const smoothFactor = 1 - Math.pow(0.85, dtSeconds * 60);

            // Ofseti yumuÅŸat
            currentBirdOffset += (targetOffset - currentBirdOffset) * smoothFactor;

            // KuÅŸun gerÃ§ek pozisyonu = Yolun Merkezi + YumuÅŸatÄ±lmÄ±ÅŸ Ofset
            bird.position.x = currentRoadX + currentBirdOffset;

            // --- MOVEMENT CLAMPING / INPUT SATURATION ---
            // EÄŸer Wall Breaker aktif DEÄžÄ°LSE, kuÅŸu yolda tut.
            // Wall Breaker aktifse, Ã§ok daha geniÅŸ bir alana (Â±22) izin ver.
            let clampWidth;
            if (wallBreakerActive) {
                clampWidth = 22.0; // Wall breaker ile dÄ±ÅŸarÄ± Ã§Ä±kabilir
            } else {
                clampWidth = originalPlayWidth; // Normal sÄ±nÄ±rlar (14.0)
            }

            const minX = currentRoadX - clampWidth;
            const maxX = currentRoadX + clampWidth;

            if (bird.position.x > maxX) {
                bird.position.x = maxX;
                currentBirdOffset = maxX - currentRoadX;
            }
            if (bird.position.x < minX) {
                bird.position.x = minX;
                currentBirdOffset = minX - currentRoadX;
            }

            const nextRoadX = getRoadX(bird.position.z - 1);
            const roadSlope = nextRoadX - currentRoadX;

            // DÃ¶nÃ¼ÅŸ efektleri
            // DÃ¶nÃ¼ÅŸ efektleri - Hedef DeÄŸerler
            const targetRotZ = (targetOffset - currentBirdOffset) * 0.3 - roadSlope * 0.5;
            const targetRotY = Math.atan2(roadSlope, -1);
            // Flappy Bird tarzÄ± rotasyon: yukarÄ± bakarken pozitif, dÃ¼ÅŸerken negatif
            const targetRotX = Math.max(-0.5, Math.min(0.5, birdVelocityY * 0.08));

            // YumuÅŸak geÃ§iÅŸ (Lerp)
            const rotSmooth = 0.15;
            bird.rotation.x += (targetRotX - bird.rotation.x) * rotSmooth;
            bird.rotation.y += (targetRotY - bird.rotation.y) * rotSmooth;
            bird.rotation.z += (targetRotZ - bird.rotation.z) * rotSmooth;

            // Kamera takibi
            const cameraOffsetZ = 15;
            const cameraTargetZ = bird.position.z + cameraOffsetZ;
            camera.position.z = cameraTargetZ;

            const roadXAtCamera = getRoadX(cameraTargetZ);

            // Kamera da yolu anlÄ±k takip etmeli, sadece kuÅŸun sapmasÄ±nÄ± yumuÅŸak takip etmeli
            // Hedef kamera ofseti (yola gÃ¶re)
            const targetCamOffset = currentBirdOffset * 0.3;

            const cameraSmoothFactor = 1 - Math.pow(0.95, dtSeconds * 60);
            cameraCurrentOffset += (targetCamOffset - cameraCurrentOffset) * cameraSmoothFactor;

            camera.position.x = roadXAtCamera + cameraCurrentOffset;

            const lookAtZ = bird.position.z - 10;
            const targetLookAtX = getRoadX(lookAtZ);

            // LookAt de yolu takip etmeli
            camera.lookAt(targetLookAtX, 0, lookAtZ);

            if (bird.position.y < -2) gameOver();

            if (lastRoadZ > bird.position.z - 100) {
                createRoadSegment();
            }

            // --- SPAWN MANTIÄžI ---
            if (bird.position.z < lastPipeZ + PIPE_DISTANCE * 2) {
                // Daha nadir power-up (%15 ÅŸans)
                if (Math.random() < 0.15) {
                    createPowerUp();
                } else {
                    createPipe();
                }
            }

            // --- POWER-UP LOOP ---
            const statusEl = document.getElementById('status-display');
            let statusText = "";

            // Efekt SÃ¼releri KontrolÃ¼
            if (shieldActive) {
                shieldTimer -= dtSeconds;
                statusText = "SHIELD: " + shieldTimer.toFixed(1) + "s";

                // Bird etrafÄ±nda kalkan efekti var mÄ±? Yoksa ekle
                if (!bird.getObjectByName('shieldSphere')) {
                    const sGeo = new THREE.SphereGeometry(1.2, 16, 16);
                    const sMat = new THREE.MeshBasicMaterial({
                        color: 0x00FFFF,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.BackSide // Ä°Ã§ini de render etmesin, sadece dÄ±ÅŸÄ±
                    });
                    const sMesh = new THREE.Mesh(sGeo, sMat);
                    sMesh.name = 'shieldSphere';
                    bird.add(sMesh);
                }

                if (shieldTimer <= 0) {
                    shieldActive = false;
                    // KalkanÄ± kaldÄ±r
                    const s = bird.getObjectByName('shieldSphere');
                    if (s) bird.remove(s);
                }
            } else {
                // Kalkan yoksa ve mesh duruyorsa temizle (reset durumlarÄ± iÃ§in)
                const s = bird.getObjectByName('shieldSphere');
                if (s) bird.remove(s);
            }

            if (wallBreakerActive) {
                wallBreakerTimer -= dtSeconds;
                if (!shieldActive) statusText = "NO WALLS: " + wallBreakerTimer.toFixed(1) + "s";
                else statusText += "<br>NO WALLS: " + wallBreakerTimer.toFixed(1) + "s";

                // DuvarlarÄ± gizle
                roadSegments.forEach(seg => {
                    seg.left.visible = false;
                    seg.right.visible = false;
                });
                pipes.forEach(p => {
                    p.leftW.visible = false;
                    p.rightW.visible = false;
                });

                if (wallBreakerTimer <= 0) {
                    wallBreakerActive = false;
                    PLAY_WIDTH = originalPlayWidth;
                    // DuvarlarÄ± geri getir
                    roadSegments.forEach(seg => {
                        seg.left.visible = true;
                        seg.right.visible = true;
                    });
                    pipes.forEach(p => {
                        p.leftW.visible = true;
                        p.rightW.visible = true;
                    });
                }
            }

            if (statusText !== "") {
                statusEl.innerHTML = statusText;
                statusEl.style.display = "block";
            } else {
                statusEl.style.display = "none";
            }

            // Power-Up Hareketi ve Ã‡arpÄ±ÅŸma
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pu = powerUps[i];

                // Rotasyon efekti
                pu.mesh.rotation.y += dtSeconds * 2;
                pu.mesh.rotation.x += dtSeconds;

                // Ã‡arpÄ±ÅŸma (Basit mesafe kontrolÃ¼)
                const dist = bird.position.distanceTo(pu.mesh.position);
                if (dist < 3.0) {
                    // ALINDI!
                    if (pu.type === 'shield') {
                        shieldActive = true;
                        shieldTimer = 5.0;
                    } else if (pu.type === 'wallBreaker') {
                        wallBreakerActive = true;
                        wallBreakerTimer = 4.0;
                        PLAY_WIDTH = 20.0;
                    }

                    scene.remove(pu.mesh);
                    powerUps.splice(i, 1);
                    continue;
                }

                if (pu.z > camera.position.z + 10) {
                    scene.remove(pu.mesh);
                    powerUps.splice(i, 1);
                }
            }


            for (let i = pipes.length - 1; i >= 0; i--) {
                const p = pipes[i];
                if (!p.passed && p.z > bird.position.z) {
                    score++;
                    document.getElementById('scoreVal').innerText = score;
                    p.passed = true;
                }

                if (Math.abs(p.z - bird.position.z) < 1.0) {
                    // EÄžER SHIELD RAKTÄ°FSE Ã‡ARPIÅžMAYI YOK SAY!
                    if (!shieldActive) {
                        const corridorHalfWidth = PIPE_WIDTH / 2 + 0.6;
                        const dx = Math.abs(currentBirdOffset - p.offset);

                        if (dx > corridorHalfWidth) {
                            gameOver();
                        } else {
                            const gapTop = p.yCenter + PIPE_GAP_Y / 2;
                            const gapBottom = p.yCenter - PIPE_GAP_Y / 2;
                            const hitY = (bird.position.y + 0.4 > gapTop) || (bird.position.y - 0.4 < gapBottom);
                            if (hitY) gameOver();
                        }
                    }
                }

                if (p.z > camera.position.z + 10) {
                    scene.remove(p.upper);
                    scene.remove(p.lower);
                    scene.remove(p.uCap);
                    scene.remove(p.lCap);
                    scene.remove(p.leftW);
                    scene.remove(p.rightW);
                    pipes.splice(i, 1);
                }
            }
        }

        function jump() {
            if (gameActive) {
                // Flappy Bird tarzÄ±: Her tÄ±klamada sabit yukarÄ± hÄ±z
                birdVelocityY = JUMP_STRENGTH;
            } else if (document.getElementById('gameOverScreen').style.display === 'block') {
                resetGame();
            } else {
                // Oyun baÅŸlatma
                gameActive = true;
                birdVelocityY = JUMP_STRENGTH;
            }
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('gameOverScreen').style.display = 'block';
            document.getElementById('finalScore').innerText = score;
        }

        window.resetGame = function () {
            pipes.forEach(p => {
                scene.remove(p.upper);
                scene.remove(p.lower);
                scene.remove(p.uCap);
                scene.remove(p.lCap);
                scene.remove(p.leftW);
                scene.remove(p.rightW);
            });
            pipes = [];
            lastPipeZ = -20;

            // Power-Up TemizliÄŸi
            powerUps.forEach(pu => scene.remove(pu.mesh));
            powerUps = [];
            shieldActive = false;
            wallBreakerActive = false;
            PLAY_WIDTH = originalPlayWidth;
            document.getElementById('status-display').style.display = 'none';
            // Varsa Shield Visual'Ä± temizle
            const s = bird.getObjectByName('shieldSphere');
            if (s) bird.remove(s);

            roadSegments.forEach(r => {
                scene.remove(r.mesh);
                scene.remove(r.left);
                scene.remove(r.right);
            });
            roadSegments = [];
            lastRoadZ = 0;
            for (let i = 0; i < 50; i++) createRoadSegment();

            bird.position.set(0, 0, 0);
            birdVelocityY = 0;
            targetBirdX = 0;
            score = 0;
            currentBirdOffset = 0;
            cameraCurrentOffset = 0;
            document.getElementById('scoreVal').innerText = '0';
            document.getElementById('gameOverScreen').style.display = 'none';
            camera.position.set(0, 4, 15);
            createPipe();
            createPipe();
            createPipe();
            gameActive = false;
        }

        function setupMediaPipe() {
            const videoElement = document.getElementById('webcam');
            const canvasElement = document.getElementById('output_canvas');
            const canvasCtx = canvasElement.getContext('2d');

            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                canvasCtx.save();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    // Ã‡izim fonksiyonlarÄ± (Sadece keypoints)
                    drawLandmarks(canvasCtx, landmarks, {
                        color: '#FF0000',
                        lineWidth: 1,
                        radius: 3
                    });

                    const cursorX = (1 - landmarks[8].x) * canvasElement.width;
                    const cursorY = landmarks[8].y * canvasElement.height;

                    const dist = Math.sqrt(
                        Math.pow(landmarks[4].x - landmarks[8].x, 2) +
                        Math.pow(landmarks[4].y - landmarks[8].y, 2)
                    );
                    const isCurrentPinch = dist < PINCH_THRESHOLD;

                    // Canvas Ã§izimi kaldÄ±rÄ±ldÄ±, sadece mantÄ±k
                    if (isCurrentPinch) {
                        const now = Date.now();
                        if (!isPinching && now - lastPinchTime > PINCH_COOLDOWN) {
                            jump();
                            lastPinchTime = now;
                            isPinching = true;
                        }
                    } else {
                        isPinching = false;
                    }

                    const normalizedX = cursorX / canvasElement.width;

                    // --- INPUT SATURATION FIX ---
                    // Normalde (normalizedX - 0.5) * (PLAY_WIDTH * 2) yapÄ±yorduk.
                    // Åžimdi inputu "overdrive" yapmak iÃ§in daha geniÅŸ bir Ã§arpan kullanÄ±yoruz.
                    // 14 birim yol iÃ§in, input aralÄ±ÄŸÄ±nÄ± 20 birim gibi hesaplÄ±yoruz.
                    // Bu sayede el kenara yaklaÅŸmadan kuÅŸ kenara yapÄ±ÅŸÄ±yor (snap feel).
                    const INPUT_RANGE = 22.0;
                    targetBirdX = (normalizedX - 0.5) * (INPUT_RANGE * 2);

                    // Not: targetBirdX burada clamp'lanmÄ±yor! updateGame iÃ§inde clamp'lanacak.
                    // Bu sayede "target" dÄ±ÅŸarÄ±da olsa bile kuÅŸ sÄ±nÄ±rda kalÄ±r, bu da hÄ±zlÄ± dÃ¶nÃ¼ÅŸ saÄŸlar.

                    // --- Cursor GÃ¼ncelleme ---
                    // El koordinatlarÄ±nÄ± (1 - landmarks[8].x) pencere boyutuna uyarla
                    const screenX = (1 - landmarks[8].x) * window.innerWidth;
                    const screenY = landmarks[8].y * window.innerHeight;

                    const cursorEl = document.getElementById('game-cursor');
                    cursorEl.style.display = 'block';
                    cursorEl.style.left = screenX + 'px';
                    cursorEl.style.top = screenY + 'px';

                    if (isCurrentPinch) {
                        cursorEl.style.backgroundColor = '#00FF00';
                        cursorEl.style.borderColor = '#00FF00';
                        cursorEl.style.boxShadow = '0 0 15px #00FF00';
                    } else {
                        cursorEl.style.backgroundColor = 'transparent';
                        cursorEl.style.borderColor = '#00FFFF';
                        cursorEl.style.boxShadow = '0 0 10px #00FFFF, inset 0 0 10px #00FFFF';
                    }
                }
                canvasCtx.restore();
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: CAMERA_WIDTH,
                height: CAMERA_HEIGHT
            });
            cameraUtils.start();
        }

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // Delta time hesaplama
            deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // FPS hesaplama
            frameCount++;
            fpsTime += deltaTime;
            if (fpsTime >= 1000) {
                currentFPS = Math.round((frameCount * 1000) / fpsTime);
                document.getElementById('fpsVal').innerText = currentFPS;
                frameCount = 0;
                fpsTime = 0;
            }

            // Oyunu delta time ile gÃ¼ncelle
            updateGame(deltaTime);
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>